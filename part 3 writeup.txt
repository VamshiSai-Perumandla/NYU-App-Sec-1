Homework Assignment 1: Part 3 Analysis
Upon executing the testcases from Part 2, namely crash1.gft, crash2.gft, hang.gft, and example.gft, we ascertained the following code coverage:
File: giftcardreader.c
Coverage: 53.22% 

In order to address sections of the code that remained uncovered, we crafted two new .gft files:

1. cov1.gft:

The initial Part 2 testcases covered record types 2 & 3. Thus, code associated with record type 1 wasn't explored. We designed cov1.gft targeting this record type, specifically the segment within the gift_card_json() function:
if (gcrd_ptr->type_of_record == 1) {
   ...
}
This effort enhanced our coverage stats:
Coverage: 71.3% 

2. cov2.gft:

The Part 2 testcases didnâ€™t touch upon switch cases beyond \0x01 and \0x09. To counter this, cov2.gft was fashioned with data bytes "\x10\04\09", bringing to light the \0x10 switch case.
The aftermath of this addition:
Coverage: 73.10%

3.fuzzer1.gft:

This fuzzer fails due to arg1 and arg 2 values. Then arg1 and arg 2 values are out of the register bound of 0 to 16. 
It access memory that is not in the bounds and this would affect pother storage location that is stored at those locations. 
to resolve this we do bound checks on arg11 and arg2. 

4.fuzzer2.gft:

This fuzzer test case fails due to arg1 being out of the char range when the following commands are run "0x03, 0x09, 0x10"
This is because the arg1 is explicitly type casted into char and this looses the precision if it is outside the char range specially negative values. 
To ignore the negative overflow values we type cast the arg1 into unsigned char and this would resolve this issue. 

After deploying these fuzzer testcases, we achieved:
Coverage: 83.5% 
