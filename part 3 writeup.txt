Homework Assignment 1: Part 3 Analysis
Upon executing the testcases from Part 2, namely crash1.gft, crash2.gft, hang.gft, and example.gft, we ascertained the following code coverage:
File: giftcardreader.c
Coverage: 53.22% 

In order to address sections of the code that remained uncovered, we crafted two new .gft files:

1. cov1.gft:

The initial Part 2 testcases covered record types 2 & 3. Thus, code associated with record type 1 wasn't explored. We designed cov1.gft targeting this record type, specifically the segment within the gift_card_json() function:
if (gcrd_ptr->type_of_record == 1) {
   ...
}
This effort enhanced our coverage stats:
Coverage: 71.3% 

2. cov2.gft:

The Part 2 testcases didnâ€™t touch upon switch cases beyond \0x01 and \0x09. To counter this, cov2.gft was fashioned with data bytes "\x10\04\09", bringing to light the \0x10 switch case.
The aftermath of this addition:
Coverage: 73.10%

3.fuzzer1.gft:

The failure of this fuzzer arises from the arg1 and arg2 values exceeding the register limit of 0 to 16. It attempts to access memory outside the designated limits, potentially impacting other data stored at those addresses. To address this, boundary checks are implemented for arg1 and arg2.

4.fuzzer2.gft:

The fuzzer test case encounters an error when arg1 falls outside the character range during the execution of commands "0x03, 0x09, 0x10". The issue stems from arg1 being forcefully type-casted to a char, which can lead to precision loss, particularly with negative values. By type-casting arg1 to an unsigned char, we can prevent negative overflow and rectify the problem.

After deploying these fuzzer testcases, we achieved:
Coverage: 83.5% 
